<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Procedural Maze Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #fff;
      height: 100%;
    }

    canvas {
      display: block;
    }

    /* HUD */
    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      gap: 12px;
      align-items: center;
      pointer-events: none;
      z-index: 10;
      text-shadow: 0 0 6px rgba(0, 255, 128, 0.6);
      user-select: none;
    }

    .hud-card {
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(0, 255, 128, 0.3);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 14px;
      letter-spacing: 0.5px;
    }

    #healthBarWrap {
      width: 200px;
      height: 12px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 6px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.08);
    }

    #healthBar {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #14ff8c, #00d6ff);
      box-shadow: 0 0 12px rgba(0, 255, 128, 0.6);
    }

    /* Center overlays */
    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.9));
      color: #eafff6;
      z-index: 20;
      text-align: center;
      flex-direction: column;
      gap: 16px;
      padding: 16px;
    }

    .overlay h1 {
      margin: 0 0 6px;
      font-weight: 700;
      letter-spacing: 1px;
      font-size: 28px;
      text-shadow: 0 0 12px rgba(0, 255, 128, 0.7);
    }

    .overlay p {
      margin: 0;
      opacity: 0.9;
    }

    .btn {
      pointer-events: auto;
      background: linear-gradient(135deg, #00ffa6, #00b3ff);
      color: #001a12;
      border: none;
      border-radius: 10px;
      padding: 12px 18px;
      font-weight: 700;
      letter-spacing: 0.6px;
      cursor: pointer;
      box-shadow: 0 8px 25px rgba(0, 255, 128, 0.35);
    }

    .btn:hover {
      filter: brightness(1.05);
    }

    /* Mobile controls */
    #mobileControls {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 15;
    }

    .joystick {
      position: absolute;
      bottom: 28px;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      border: 1px dashed rgba(0, 255, 128, 0.4);
      background: radial-gradient(circle at center, rgba(0, 255, 128, 0.08), rgba(0, 255, 128, 0.03));
      pointer-events: auto;
      touch-action: none;
    }

    #joyMove {
      left: 24px;
    }

    #joyLook {
      right: 24px;
    }

    .stick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 30% 30%, #00ffa6, #00a1ff);
      opacity: 0.9;
      box-shadow: 0 0 12px rgba(0, 255, 128, 0.6);
    }

    /* Corner tips */
    #tips {
      position: fixed;
      bottom: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(0, 255, 128, 0.25);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      z-index: 10;
      pointer-events: none;
      color: #cffff0;
    }

    a,
    a:visited {
      color: #9fffe0;
    }
  </style>

  <!-- Core libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
  <script src="https://unpkg.com/yuka@0.7.8/build/yuka.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
</head>

<body>
  <div id="hud">
    <div class="hud-card">Time: <span id="time">120</span>s</div>
    <div class="hud-card">FPS: <span id="fps">60</span></div>
    <div class="hud-card">Score: <span id="score">0</span></div>
    <div class="hud-card" style="display:flex; gap:8px; align-items:center;">
      Health:
      <div id="healthBarWrap">
        <div id="healthBar"></div>
      </div>
      <span id="healthText">100</span>
    </div>
    <div class="hud-card">Best: <span id="best">0</span></div>
  </div>

  <div id="tips">WASD to move Mouse to look Space to jump Avoid enemies and spikes Collect orbs Find the red portal
  </div>

  <div id="startOverlay" class="overlay">
    <h1>Procedural Maze Runner</h1>
    <p>Navigate the glowing labyrinth. Avoid patrols, collect orbs, and reach the portal before time runs out.</p>
    <p style="opacity:0.8;">Desktop: WASD + Mouse (click to capture) Mobile: Dual joysticks</p>
    <button id="startBtn" class="btn">Click to Start</button>
  </div>

  <div id="endOverlay" class="overlay" style="display:none;">
    <h1 id="endTitle">You Escaped!</h1>
    <p id="endDetails"></p>
    <div style="display:flex; gap:10px; margin-top:8px;">
      <button id="restartBtn" class="btn">Restart</button>
    </div>
  </div>

  <!-- Mobile controls -->
  <div id="mobileControls" style="display:none;">
    <div id="joyMove" class="joystick">
      <div class="stick" id="stickMove"></div>
    </div>
    <div id="joyLook" class="joystick">
      <div class="stick" id="stickLook"></div>
    </div>
  </div>

  <script>
    window.addEventListener('load', () => {
      'use strict';
      if (!window.THREE) {
        console.error('Three.js failed to load.');
        alert('Three.js failed to load from CDN. Please check your internet connection and reload, or run via a local server.');
        return;
      }

      // --------------------------
      // Config / Difficulty scaling
      // --------------------------
      const BASE_TIME_LIMIT = 120; // seconds
      const PLAYER_BASE_SPEED = 4.4; // m/s
      const PLAYER_SPRINT_SPEED = 6.2;
      const PLAYER_RADIUS = 0.35;
      const PLAYER_EYE_HEIGHT = 1.6;
      const JUMP_VELOCITY = 6.8;
      const GRAVITY = 20.0;

      const BASE_MAZE_SIZE = 10; // NxN
      const CELL_SIZE = 4.0;
      const WALL_HEIGHT = 3.2;
      const WALL_THICKNESS = 0.33;

      const COLLECTIBLES_COUNT = 8;
      const HAZARD_COUNT = 8;

      const STORAGE_KEYS = {
        best: 'pmr_best_score',
        difficulty: 'pmr_difficulty_level'
      };

      let difficultyLevel = parseInt(localStorage.getItem(STORAGE_KEYS.difficulty) || '0', 10);
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

      const mazeSize = clamp(BASE_MAZE_SIZE + difficultyLevel * 2, 8, 26);
      const enemyCount = clamp(2 + Math.floor(difficultyLevel / 2), 2, 6);
      let TIME_LIMIT = BASE_TIME_LIMIT;

      // --------------------------
      // Three.js scene setup
      // --------------------------
      let scene, camera, renderer, clock;
      let mazeGroup, wallIMesh, gridHelper, floorMesh;
      let startMarker, exitPortal;
      let ambientLight, pointLight;

      // Visual extras
      let decorGroup = null; // wall paintings & art panels
      let dustPoints = null; // floating dust motes
      let dustData = []; // {vx, vy}
      let sweepMesh = null; // sweeping light band
      const portalSprites = []; // additive glow sprites

      // Performance and feature toggles
      const perf = { frames: 0, acc: 0, fps: 60, level: 1, lastEval: 0, lastPaintingScan: 0 };
      const settings = { aiPaintingEnabled: false, useTFPainting: false };
      let paintingGenActive = false;
      let paintingGenQuota = 2; // per minute
      let paintingGenRefillAt = 0;
      let paintingLightCount = 0;
      let paintingLightCap = 8;
      let paintingCap = 20;
      let enemyUpdateToggle = false;
      let paintingCount = 0;
      let paintingTexturePool = [];

      function makeProceduralPaintingTexture(w = 256, h = 256) {
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const g = c.getContext('2d');
        const grad = g.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#07161a'); grad.addColorStop(1, '#0b0f20');
        g.fillStyle = grad; g.fillRect(0, 0, w, h);
        for (let i = 0; i < 5; i++) {
          const cx = Math.random() * w, cy = Math.random() * h; const r = 26 + Math.random() * 66;
          const gg = g.createRadialGradient(cx, cy, 1, cx, cy, r);
          gg.addColorStop(0, `hsla(${180 + Math.random() * 120},100%,65%,0.85)`);
          gg.addColorStop(1, 'rgba(0,0,0,0)');
          g.globalCompositeOperation = 'lighter'; g.fillStyle = gg; g.beginPath(); g.arc(cx, cy, r, 0, Math.PI * 2); g.fill();
        }
        g.globalCompositeOperation = 'source-over';
        g.lineCap = 'round'; g.lineJoin = 'round'; g.lineWidth = 6;
        for (let i = 0; i < 4; i++) {
          g.strokeStyle = `hsla(${140 + Math.random() * 160},100%,70%,0.95)`;
          g.beginPath(); let x = Math.random() * w * 0.1, y = Math.random() * h; g.moveTo(x, y);
          for (let s = 0; s < 5; s++) { x += w * (0.18 + Math.random() * 0.22); y += (Math.random() - 0.5) * h * 0.35; g.quadraticCurveTo(x - 24, y - 18, x, y); }
          g.stroke();
        }
        const tex = new THREE.CanvasTexture(c); tex.anisotropy = 2; tex.needsUpdate = true; return tex;
      }

      function buildPaintingTexturePool(size = 6) {
        paintingTexturePool = [];
        for (let i = 0; i < size; i++) paintingTexturePool.push(makeProceduralPaintingTexture(256, 256));
      }

      function applyPerfLevel(level) {
        perf.level = level;
        const dprNormal = clamp(window.devicePixelRatio || 1, 1, 2);
        if (level === 0) {
          renderer.setPixelRatio(dprNormal);
          if (dustPoints) { dustPoints.visible = true; const cnt = dustPoints.geometry.getAttribute('position')?.count || 0; dustPoints.geometry.setDrawRange(0, cnt); if (dustPoints.material) dustPoints.material.opacity = 0.18; }
          if (sweepMesh?.material) { sweepMesh.visible = true; sweepMesh.material.opacity = 0.35; }
          portalSprites.forEach(s => s.visible = true);
          settings.aiPaintingEnabled = true;
          paintingLightCap = 8;
          // enable painting lamps
          if (decorGroup) decorGroup.children.forEach(obj => { const p = obj.userData?.painting; if (p?.lamp) p.lamp.visible = true; });
        } else if (level === 1) {
          renderer.setPixelRatio(0.85);
          if (dustPoints) { const cnt = dustPoints.geometry.getAttribute('position')?.count || 0; dustPoints.geometry.setDrawRange(0, Math.floor(cnt * 0.5)); if (dustPoints.material) dustPoints.material.opacity = 0.1; }
          if (sweepMesh) { sweepMesh.visible = false; }
          portalSprites.forEach((s, i) => s.visible = i === 0);
          settings.aiPaintingEnabled = true;
          paintingLightCap = 4;
          if (decorGroup) decorGroup.children.forEach(obj => { const p = obj.userData?.painting; if (p?.lamp) p.lamp.visible = false; });
        } else {
          renderer.setPixelRatio(0.6);
          if (dustPoints) dustPoints.visible = false;
          if (sweepMesh) sweepMesh.visible = false;
          portalSprites.forEach(s => s.visible = false);
          settings.aiPaintingEnabled = false;
          paintingLightCap = 2;
          if (decorGroup) decorGroup.children.forEach(obj => { const p = obj.userData?.painting; if (p?.lamp) p.lamp.visible = false; });
        }
      }

      // Third-person player + chaser
      let playerAvatar = null; // Group attached to yawObject
      let kidChaser = null; // { group, speed, swing, attackCooldown, replan }

      // Audio
      let listener, masterGain, audioEnabled = false;
      let sfxGain = null; // subgroup for SFX

      // Player + controls
      const keyState = { w: false, a: false, s: false, d: false, space: false, shift: false };
      let velocityY = 0, isOnGround = true;
      const yawObject = new THREE.Object3D();
      const pitchObject = new THREE.Object3D();
      let isPointerLocked = false;

      // Raycaster for wall collisions
      const raycaster = new THREE.Raycaster();
      raycaster.far = 2.0;

      // Game state
      let isRunning = false;
      let timeRemaining = TIME_LIMIT;
      let score = 0;
      let health = 100;
      let bestScore = parseInt(localStorage.getItem(STORAGE_KEYS.best) || '0', 10);
      let lastFrameTime = 0;

      // Maze data
      let grid, openCells = [];
      let startCell = { x: 0, y: 0 };
      let exitCell = { x: mazeSize - 1, y: mazeSize - 1 };
      let exitPosition = new THREE.Vector3();

      // Entities
      const collectibles = [];
      const hazards = [];
      const enemies = []; // { vehicle, mesh }

      // YUKA (optional)
      let entityManager = null;
      if (window.YUKA) {
        entityManager = new YUKA.EntityManager();
      } else {
        console.warn('YUKA failed to load from CDN; enemies will be disabled.');
      }

      // TF.js tracking
      const positionSamples = [];
      let tfModel = null;
      let aiAdaptCooldown = 0;

      // --------------------------
      // Global painting generators (accessible everywhere)
      // --------------------------
      async function createPaintingTexture(w = 256, h = 256) {
        // Optionally try TF first
        if (settings.useTFPainting && typeof tf !== 'undefined') {
          try {
            const tex = await createAIPaintingTexture(w, h);
            if (tex) return tex;
          } catch { /* fall through */ }
        }
        // Procedural high-contrast neon abstract
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const g = c.getContext('2d');
        const grad = g.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#07161a'); grad.addColorStop(1, '#0b0f20');
        g.fillStyle = grad; g.fillRect(0, 0, w, h);
        for (let i = 0; i < 5; i++) {
          const cx = Math.random() * w, cy = Math.random() * h; const r = 26 + Math.random() * 66;
          const gg = g.createRadialGradient(cx, cy, 1, cx, cy, r);
          gg.addColorStop(0, `hsla(${180 + Math.random() * 120},100%,65%,0.85)`);
          gg.addColorStop(1, 'rgba(0,0,0,0)');
          g.globalCompositeOperation = 'lighter'; g.fillStyle = gg; g.beginPath(); g.arc(cx, cy, r, 0, Math.PI * 2); g.fill();
        }
        g.globalCompositeOperation = 'source-over';
        g.lineCap = 'round'; g.lineJoin = 'round'; g.lineWidth = 6;
        for (let i = 0; i < 4; i++) {
          g.strokeStyle = `hsla(${140 + Math.random() * 160},100%,70%,0.95)`;
          g.beginPath();
          let x = Math.random() * w * 0.1, y = Math.random() * h;
          g.moveTo(x, y);
          for (let s = 0; s < 5; s++) {
            x += w * (0.18 + Math.random() * 0.22);
            y += (Math.random() - 0.5) * h * 0.35;
            g.quadraticCurveTo(x - 24, y - 18, x, y);
          }
          g.stroke();
        }
        return new THREE.CanvasTexture(c);
      }

      async function createAIPaintingDetailTexture(w = 384, h = 384) {
        if (!settings.useTFPainting || typeof tf === 'undefined') return null;
        try {
          const t = tf.tidy(() => {
            let img = tf.randomUniform([h, w, 3]);
            const k = tf.tensor4d([
              [[[1]], [[2]], [[1]]],
              [[[2]], [[4]], [[2]]],
              [[[1]], [[2]], [[1]]]
            ], [3, 3, 1, 1]).div(16);
            for (let i = 0; i < 3; i++) {
              const r = tf.conv2d(img.slice([0, 0, 0], [h, w, 1]), k, 1, 'same');
              const g = tf.conv2d(img.slice([0, 0, 1], [h, w, 1]), k, 1, 'same');
              const b = tf.conv2d(img.slice([0, 0, 2], [h, w, 1]), k, 1, 'same');
              img = tf.concat([r, g, b], 2);
            }
            const tint = tf.tensor([1.0, 0.95 + Math.random() * 0.1, 0.9 + Math.random() * 0.2]);
            img = img.mul(tint);
            return img.clipByValue(0, 1).mul(255).toInt();
          });
          const arr = await t.data(); t.dispose && t.dispose();
          const c = document.createElement('canvas'); c.width = w; c.height = h;
          const g = c.getContext('2d'); const imgData = g.createImageData(w, h);
          for (let i = 0, p = 0; i < w * h; i++, p += 4) { imgData.data[p + 0] = arr[i * 3 + 0]; imgData.data[p + 1] = arr[i * 3 + 1]; imgData.data[p + 2] = arr[i * 3 + 2]; imgData.data[p + 3] = 255; }
          g.putImageData(imgData, 0, 0);
          const tex = new THREE.CanvasTexture(c); tex.anisotropy = 4; tex.needsUpdate = true; return tex;
        } catch { return null; }
      }

      // DOM
      const hudTime = document.getElementById('time');
      const hudScore = document.getElementById('score');
      const hudHealth = document.getElementById('healthText');
      const healthBar = document.getElementById('healthBar');
      const hudBest = document.getElementById('best');
      const startOverlay = document.getElementById('startOverlay');
      const endOverlay = document.getElementById('endOverlay');
      const endTitle = document.getElementById('endTitle');
      const endDetails = document.getElementById('endDetails');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');

      const mobileControls = document.getElementById('mobileControls');
      const joyMove = document.getElementById('joyMove');
      const stickMove = document.getElementById('stickMove');
      const joyLook = document.getElementById('joyLook');
      const stickLook = document.getElementById('stickLook');
      let isMobile = /Mobi|Android/i.test(navigator.userAgent);

      // --------------------------
      // Init
      // --------------------------
      function init() {
        hudBest.textContent = bestScore;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x00110b, 14, 120);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 500);
        // Keep camera separate from pitchObject so WASD translation doesn't change perceived zoom
        scene.add(camera);
        pitchObject.position.y = PLAYER_EYE_HEIGHT;
        yawObject.add(pitchObject);
        scene.add(yawObject);
        // Initial placement; subsequent frames are controlled by updateThirdPersonCamera
        camera.position.set(0, 1.6, 6.0);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(clamp(window.devicePixelRatio || 1, 1, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // Lights
        ambientLight = new THREE.AmbientLight(0x88ffc8, 0.35);
        scene.add(ambientLight);

        pointLight = new THREE.PointLight(0x00ffaa, 1.0, 60, 2.0);
        pointLight.position.set(0, 6, 0);
        scene.add(pointLight);

        // Audio
        listener = new THREE.AudioListener();
        camera.add(listener);
        try {
          masterGain = listener.context.createGain();
          masterGain.connect(listener.context.destination);
          sfxGain = listener.context.createGain();
          sfxGain.gain.value = 0.7;
          sfxGain.connect(masterGain);
        } catch (e) {
          // ignore
        }

        // Maze
        generateAndBuildMaze();

        // UI and events
        setupControls();
        setupMobileControls();

        // Start overlay click
        startBtn.addEventListener('click', () => {
          // decide on TF usage based on hardware (mobile low end off by default)
          const isLowEnd = /Mobi|Android/i.test(navigator.userAgent) || (navigator.hardwareConcurrency || 2) <= 4;
          settings.useTFPainting = !isLowEnd; // enable on desktop by default
          beginGame();
        });
        restartBtn.addEventListener('click', () => {
          location.reload();
        });

        window.addEventListener('resize', onWindowResize);
      }

      function onWindowResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }

      // --------------------------
      // Controls
      // --------------------------
      function setupControls() {
        document.addEventListener('keydown', (e) => {
          switch (e.code) {
            case 'KeyW': keyState.w = true; break;
            case 'KeyA': keyState.a = true; break;
            case 'KeyS': keyState.s = true; break;
            case 'KeyD': keyState.d = true; break;
            case 'Space': keyState.space = true; break;
            case 'ShiftLeft': keyState.shift = true; break;
          }
        });
        document.addEventListener('keyup', (e) => {
          switch (e.code) {
            case 'KeyW': keyState.w = false; break;
            case 'KeyA': keyState.a = false; break;
            case 'KeyS': keyState.s = false; break;
            case 'KeyD': keyState.d = false; break;
            case 'Space': keyState.space = false; break;
            case 'ShiftLeft': keyState.shift = false; break;
          }
        });

        // Pointer lock style look
        const mouseMove = (e) => {
          if (!isPointerLocked) return;
          const mx = e.movementX || 0;
          const my = e.movementY || 0;
          const yaw = yawObject.rotation.y - mx * 0.0025;
          const pitch = pitchObject.rotation.x - my * 0.002;
          yawObject.rotation.y = yaw;
          pitchObject.rotation.x = clamp(pitch, -Math.PI / 2 + 0.02, Math.PI / 2 - 0.02);
        };
        document.addEventListener('mousemove', mouseMove);

        document.addEventListener('pointerlockchange', () => {
          isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        // Optional non-pointer-lock look (drag)
        let isDragging = false, lastX = 0, lastY = 0;
        renderer.domElement.addEventListener('mousedown', (e) => {
          if (isPointerLocked) return;
          isDragging = true; lastX = e.clientX; lastY = e.clientY;
        });
        renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
        renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });
        renderer.domElement.addEventListener('mousemove', (e) => {
          if (!isDragging || isPointerLocked) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          lastX = e.clientX; lastY = e.clientY;
          yawObject.rotation.y -= dx * 0.003;
          pitchObject.rotation.x = clamp(pitchObject.rotation.x - dy * 0.0025, -Math.PI / 2 + 0.02, Math.PI / 2 - 0.02);
        });
      }

      function setupMobileControls() {
        if (!isMobile) return;
        mobileControls.style.display = 'block';

        setupJoystick(joyMove, stickMove, (nx, ny) => {
          mobileMoveInput.x = nx;
          mobileMoveInput.y = ny;
        });
        setupJoystick(joyLook, stickLook, (nx, ny) => {
          // look: nx -> yaw, ny -> pitch
          yawObject.rotation.y -= nx * 0.04;
          pitchObject.rotation.x = clamp(pitchObject.rotation.x - ny * 0.03, -Math.PI / 2 + 0.02, Math.PI / 2 - 0.02);
        });
      }

      const mobileMoveInput = { x: 0, y: 0 }; // -1..1

      function setupJoystick(baseEl, stickEl, onChange) {
        const rect = () => baseEl.getBoundingClientRect();
        const center = () => ({ x: rect().left + rect().width / 2, y: rect().top + rect().height / 2 });
        const radius = () => rect().width * 0.5 - 6;

        let active = false;
        function updateTouch(clientX, clientY) {
          const c = center();
          const dx = clientX - c.x;
          const dy = clientY - c.y;
          const angle = Math.atan2(dy, dx);
          const dist = Math.min(Math.hypot(dx, dy), radius());
          const sx = Math.cos(angle) * dist;
          const sy = Math.sin(angle) * dist;
          stickEl.style.transform = `translate(${sx}px, ${sy}px) translate(-50%,-50%)`;

          const nx = sx / radius();
          const ny = sy / radius();
          onChange(nx, ny);
        }
        function reset() {
          stickEl.style.transform = `translate(-50%,-50%)`;
          onChange(0, 0);
        }
        baseEl.addEventListener('pointerdown', (e) => { active = true; baseEl.setPointerCapture(e.pointerId); updateTouch(e.clientX, e.clientY); });
        baseEl.addEventListener('pointermove', (e) => { if (!active) return; updateTouch(e.clientX, e.clientY); });
        baseEl.addEventListener('pointerup', () => { active = false; reset(); });
        baseEl.addEventListener('pointercancel', () => { active = false; reset(); });
      }

      function requestPointerLock() {
        if (isMobile) return;
        renderer.domElement.requestPointerLock?.();
      }

      // --------------------------
      // Maze generation (DFS backtracker)
      // --------------------------
      function generateMaze(cols, rows) {
        const cells = [];
        for (let y = 0; y < rows; y++) {
          const row = [];
          for (let x = 0; x < cols; x++) {
            row.push({
              x, y, visited: false,
              walls: { n: true, e: true, s: true, w: true }
            });
          }
          cells.push(row);
        }
        function neighbors(cell) {
          const out = [];
          const { x, y } = cell;
          if (y > 0) out.push({ dir: 'n', nx: x, ny: y - 1, opp: 's' });
          if (x < cols - 1) out.push({ dir: 'e', nx: x + 1, ny: y, opp: 'w' });
          if (y < rows - 1) out.push({ dir: 's', nx: x, ny: y + 1, opp: 'n' });
          if (x > 0) out.push({ dir: 'w', nx: x - 1, ny: y, opp: 'e' });
          return out;
        }
        const stack = [];
        let current = cells[startCell.y][startCell.x];
        current.visited = true;
        let visitedCount = 1;
        const total = cols * rows;

        while (visitedCount < total) {
          const nbs = neighbors(current).filter(n => !cells[n.ny][n.nx].visited);
          if (nbs.length > 0) {
            const pick = nbs[(Math.random() * nbs.length) | 0];
            // carve wall
            current.walls[pick.dir] = false;
            const next = cells[pick.ny][pick.nx];
            next.walls[pick.opp] = false;
            stack.push(current);
            current = next;
            current.visited = true;
            visitedCount++;
          } else if (stack.length > 0) {
            current = stack.pop();
          } else {
            // fallback if disconnected
            outer: for (let yy = 0; yy < rows; yy++) {
              for (let xx = 0; xx < cols; xx++) {
                if (!cells[yy][xx].visited) {
                  current = cells[yy][xx];
                  current.visited = true;
                  visitedCount++;
                  break outer;
                }
              }
            }
          }
        }

        // mark all open cells (centers)
        const opens = [];
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            opens.push({ x, y });
          }
        }
        return { cells, opens };
      }

      function buildMaze(cells, cols, rows) {
        if (mazeGroup) {
          scene.remove(mazeGroup);
          mazeGroup.traverse(o => {
            if (o.geometry) o.geometry.dispose?.();
            if (o.material) {
              if (Array.isArray(o.material)) o.material.forEach(m => m.dispose?.());
              else o.material.dispose?.();
            }
          });
        }
        mazeGroup = new THREE.Group();
        scene.add(mazeGroup);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(cols * CELL_SIZE, rows * CELL_SIZE, 1, 1);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x031c14, roughness: 0.8, metalness: 0.1 });
        floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.set((cols * CELL_SIZE) / 2 - CELL_SIZE / 2, 0, (rows * CELL_SIZE) / 2 - CELL_SIZE / 2);
        mazeGroup.add(floorMesh);

        gridHelper = new THREE.GridHelper(cols * CELL_SIZE, cols, 0x0aff8a, 0x001a12);
        gridHelper.material.opacity = 0.25;
        gridHelper.material.transparent = true;
        gridHelper.position.copy(floorMesh.position);
        gridHelper.position.y = 0.01;
        mazeGroup.add(gridHelper);

        // Walls via InstancedMesh
        const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, WALL_THICKNESS);
        const wallMat = new THREE.MeshStandardMaterial({
          color: 0x00ff84,
          transparent: true,
          opacity: 0.85,
          emissive: 0x00ff84,
          emissiveIntensity: 0.5
        });

        // Count walls
        let wallCount = 0;
        const half = CELL_SIZE / 2;
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const c = cells[y][x];
            if (c.walls.n) wallCount++;
            if (c.walls.s) wallCount++;
            if (c.walls.e) wallCount++;
            if (c.walls.w) wallCount++;
          }
        }
        // outer boundaries
        wallCount += cols * 2 + rows * 2;

        wallIMesh = new THREE.InstancedMesh(wallGeo, wallMat, wallCount);
        wallIMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        mazeGroup.add(wallIMesh);

        // Decorative group for paintings (pooled, capped)
        if (decorGroup) { mazeGroup.remove(decorGroup); }
        decorGroup = new THREE.Group();
        mazeGroup.add(decorGroup);
        paintingCount = 0;
        buildPaintingTexturePool(6);

        let idx = 0;
        const m = new THREE.Matrix4();
        const q = new THREE.Quaternion();
        const v = new THREE.Vector3();
        const s = new THREE.Vector3(1, 1, 1);

        // Create an abstract neon painting texture
        function createAIPaintingTexture(w = 256, h = 256) {
          if (typeof tf === 'undefined') return null;
          try {
            // Generate smooth noise field with simple blur via conv-like averaging
            const t = tf.tidy(() => {
              const noise = tf.randomUniform([h, w, 3]);
              // simple 3x3 average blur by repeated depthwise conv emulation
              const k = tf.tensor4d([
                [[[1]], [[1]], [[1]]],
                [[[1]], [[2]], [[1]]],
                [[[1]], [[1]], [[1]]]
              ], [3, 3, 1, 1]).div(10);
              let img = noise;
              // approximate blur per channel
              for (let i = 0; i < 2; i++) {
                const r = tf.conv2d(img.slice([0, 0, 0], [h, w, 1]), k, 1, 'same');
                const g = tf.conv2d(img.slice([0, 0, 1], [h, w, 1]), k, 1, 'same');
                const b = tf.conv2d(img.slice([0, 0, 2], [h, w, 1]), k, 1, 'same');
                img = tf.concat([r, g, b], 2);
              }
              return img.mul(0.9).clipByValue(0, 1);
            });
            const data = t.mul(255).toInt();
            return data.data().then(arr => {
              const c = document.createElement('canvas'); c.width = w; c.height = h;
              const g = c.getContext('2d');
              const imgData = g.createImageData(w, h);
              for (let i = 0, p = 0; i < w * h; i++, p += 4) {
                imgData.data[p + 0] = arr[i * 3 + 0];
                imgData.data[p + 1] = arr[i * 3 + 1];
                imgData.data[p + 2] = arr[i * 3 + 2];
                imgData.data[p + 3] = 255;
              }
              g.putImageData(imgData, 0, 0);
              const tex = new THREE.CanvasTexture(c); tex.anisotropy = 4; tex.needsUpdate = true; return tex;
            }).finally(() => { t.dispose && t.dispose(); });
          } catch {
            return null;
          }
        }

        async function createPaintingTexture(w = 256, h = 256) {
          // Try AI-backed texture first
          let aiTex = null;
          if (settings.useTFPainting && typeof tf !== 'undefined') {
            aiTex = await createAIPaintingTexture(w, h);
          }
          if (aiTex) return aiTex;
          const c = document.createElement('canvas'); c.width = w; c.height = h;
          const g = c.getContext('2d');
          // High-contrast layered background
          const grad = g.createLinearGradient(0, 0, w, h);
          grad.addColorStop(0, '#07161a'); grad.addColorStop(1, '#0b0f20');
          g.fillStyle = grad; g.fillRect(0, 0, w, h);
          // geometric shapes
          for (let i = 0; i < 5; i++) {
            const cx = Math.random() * w, cy = Math.random() * h; const r = 26 + Math.random() * 66;
            const gg = g.createRadialGradient(cx, cy, 1, cx, cy, r);
            gg.addColorStop(0, `hsla(${180 + Math.random() * 120},100%,65%,0.85)`);
            gg.addColorStop(1, 'rgba(0,0,0,0)');
            g.globalCompositeOperation = 'lighter'; g.fillStyle = gg; g.beginPath(); g.arc(cx, cy, r, 0, Math.PI * 2); g.fill();
          }
          g.globalCompositeOperation = 'source-over';
          // bold neon strokes
          g.lineCap = 'round'; g.lineJoin = 'round'; g.lineWidth = 6;
          for (let i = 0; i < 4; i++) {
            g.strokeStyle = `hsla(${140 + Math.random() * 160},100%,70%,0.95)`;
            g.beginPath();
            let x = Math.random() * w * 0.1, y = Math.random() * h;
            g.moveTo(x, y);
            for (let s = 0; s < 5; s++) {
              x += w * (0.18 + Math.random() * 0.22);
              y += (Math.random() - 0.5) * h * 0.35;
              g.quadraticCurveTo(x - 24, y - 18, x, y);
            }
            g.stroke();
          }
          return new THREE.CanvasTexture(c);
        }

        async function createAIPaintingDetailTexture(w = 384, h = 384) {
          if (!settings.useTFPainting || typeof tf === 'undefined') return null;
          try {
            const t = tf.tidy(() => {
              let img = tf.randomUniform([h, w, 3]);
              const k = tf.tensor4d([
                [[[1]], [[2]], [[1]]],
                [[[2]], [[4]], [[2]]],
                [[[1]], [[2]], [[1]]]
              ], [3, 3, 1, 1]).div(16);
              for (let i = 0; i < 3; i++) {
                const r = tf.conv2d(img.slice([0, 0, 0], [h, w, 1]), k, 1, 'same');
                const g = tf.conv2d(img.slice([0, 0, 1], [h, w, 1]), k, 1, 'same');
                const b = tf.conv2d(img.slice([0, 0, 2], [h, w, 1]), k, 1, 'same');
                img = tf.concat([r, g, b], 2);
              }
              const tint = tf.tensor([1.0, 0.95 + Math.random() * 0.1, 0.9 + Math.random() * 0.2]);
              img = img.mul(tint);
              return img.clipByValue(0, 1).mul(255).toInt();
            });
            const arr = await t.data();
            t.dispose && t.dispose();
            const c = document.createElement('canvas'); c.width = w; c.height = h;
            const g = c.getContext('2d');
            const imgData = g.createImageData(w, h);
            for (let i = 0, p = 0; i < w * h; i++, p += 4) {
              imgData.data[p + 0] = arr[i * 3 + 0];
              imgData.data[p + 1] = arr[i * 3 + 1];
              imgData.data[p + 2] = arr[i * 3 + 2];
              imgData.data[p + 3] = 255;
            }
            g.putImageData(imgData, 0, 0);
            const tex = new THREE.CanvasTexture(c); tex.anisotropy = 4; tex.needsUpdate = true; return tex;
          } catch { return null; }
        }

        // Maybe add a painting to a wall segment
        async function maybeAddPainting(wx, wy, angleRad) {
          if (paintingCount >= paintingCap) return;
          if (Math.random() > 0.18) return;
          const panelW = CELL_SIZE * (0.6 + Math.random() * 0.3);
          const panelH = WALL_HEIGHT * (0.65 + Math.random() * 0.28);
          // Grab a pooled texture (no generation cost at runtime)
          const tex = paintingTexturePool[(Math.random() * paintingTexturePool.length) | 0] || makeProceduralPaintingTexture(256, 256);
          tex.anisotropy = 4; tex.needsUpdate = true;

          const artMat = new THREE.MeshStandardMaterial({
            map: tex,
            emissive: new THREE.Color(0x7fffe0).multiplyScalar(0.25),
            emissiveIntensity: 0.9,
            metalness: 0.08,
            roughness: 0.5,
            transparent: false,
            side: THREE.DoubleSide
          });
          const artGeo = new THREE.PlaneGeometry(panelW * 0.96, panelH * 0.96);
          const art = new THREE.Mesh(artGeo, artMat);

          // Frame
          const frameMat = new THREE.MeshStandardMaterial({ color: 0x0b1a16, metalness: 0.65, roughness: 0.25 });
          const frameGeo = new THREE.PlaneGeometry(panelW, panelH);
          const frame = new THREE.Mesh(frameGeo, frameMat);

          // Mount
          const group = new THREE.Group();
          frame.position.z = 0; // base
          art.position.z = 0.01; // slightly forward to avoid z-fighting
          group.add(frame);
          group.add(art);

          // Place slightly off the wall towards one side
          const normal = new THREE.Vector3(Math.sin(angleRad), 0, Math.cos(angleRad));
          const side = Math.random() < 0.5 ? 1 : -1;
          const offset = normal.clone().multiplyScalar(side * (WALL_THICKNESS * 0.5 + 0.08));
          const mountY = WALL_HEIGHT * (0.58 + Math.random() * 0.18);
          group.position.set(wx + offset.x, mountY, wy + offset.z);
          group.rotation.y = angleRad + (side < 0 ? Math.PI : 0);
          group.userData.type = 'painting';
          group.userData.painting = { artMesh: art, generated: false, generating: false, lastTry: 0 };
          decorGroup.add(group);
          paintingCount++;

          // Accent light to make painting pop
          const lamp = new THREE.PointLight(0x9ffff0, 0.5, 2.0, 1.8);
          lamp.position.set(0, panelH * 0.55, 0.1);
          group.add(lamp);
          if (!group.userData.painting) group.userData.painting = {};
          group.userData.painting.lamp = lamp;

          // Soft glow sprite above
          const glowTex = makeCircleSprite(64);
          const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: 0xcffff6, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.35 }));
          glow.scale.set(0.6, 0.6, 1);
          glow.position.set(0, panelH * 0.6, 0.06);
          group.add(glow);
        }

        const placeWall = async (wx, wy, angleRad) => {
          v.set(wx, WALL_HEIGHT / 2, wy);
          q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angleRad);
          m.compose(v, q, s);
          wallIMesh.setMatrixAt(idx++, m);
          maybeAddPainting(wx, wy, angleRad);
        };

        // Cells
        (async () => {
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              const c = cells[y][x];
              const cx = x * CELL_SIZE;
              const cz = y * CELL_SIZE;
              const centerX = cx + half;
              const centerZ = cz + half;

              if (c.walls.n) await placeWall(centerX, cz, 0);
              if (c.walls.s) await placeWall(centerX, cz + CELL_SIZE, 0);
              if (c.walls.w) await placeWall(cx, centerZ, Math.PI / 2);
              if (c.walls.e) await placeWall(cx + CELL_SIZE, centerZ, Math.PI / 2);
            }
          }
          wallIMesh.instanceMatrix.needsUpdate = true;
        })();

        // Outer boundaries
        (async () => {
          for (let x = 0; x < cols; x++) {
            const cx = x * CELL_SIZE + half;
            await placeWall(cx, -0.0, 0);
            await placeWall(cx, rows * CELL_SIZE + 0.0, 0);
          }
          for (let y = 0; y < rows; y++) {
            const cz = y * CELL_SIZE + half;
            await placeWall(-0.0, cz, Math.PI / 2);
            await placeWall(cols * CELL_SIZE + 0.0, cz, Math.PI / 2);
          }
          wallIMesh.instanceMatrix.needsUpdate = true;
        })();

        // Start / Exit
        const startPos = cellCenterWorld(startCell.x, startCell.y);
        startMarker = new THREE.Mesh(
          new THREE.SphereGeometry(0.35, 16, 12),
          new THREE.MeshStandardMaterial({ color: 0x00ff9d, emissive: 0x00ff9d, emissiveIntensity: 0.6, transparent: true, opacity: 0.9 })
        );
        startMarker.position.copy(startPos).y = 0.35;
        mazeGroup.add(startMarker);

        exitPosition.copy(cellCenterWorld(exitCell.x, exitCell.y));
        exitPortal = new THREE.Mesh(
          new THREE.TorusGeometry(0.75, 0.23, 16, 64),
          new THREE.MeshStandardMaterial({ color: 0xff005c, emissive: 0xff003b, emissiveIntensity: 0.8, metalness: 0.2, roughness: 0.2 })
        );
        exitPortal.position.copy(exitPosition).y = 1.2;
        mazeGroup.add(exitPortal);

        // Add extras: portal glow, dust, and a sweeping light band
        enhancePortal();
        setupDustMotes(cols, rows);
        setupLightSweep(cols, rows);
      }

      function cellCenterWorld(x, y) {
        const wx = x * CELL_SIZE + CELL_SIZE / 2;
        const wz = y * CELL_SIZE + CELL_SIZE / 2;
        return new THREE.Vector3(wx, 0, wz);
      }

      function generateAndBuildMaze() {
        const result = generateMaze(mazeSize, mazeSize);
        grid = result.cells;
        openCells = result.opens;

        buildMaze(grid, mazeSize, mazeSize);

        // Place player at start
        const startPos = cellCenterWorld(startCell.x, startCell.y);
        yawObject.position.set(startPos.x, 0, startPos.z);
        pitchObject.position.y = PLAYER_EYE_HEIGHT;

        // Create third-person avatar
        if (playerAvatar) { yawObject.remove(playerAvatar); }
        playerAvatar = createPlayerAvatar();
        yawObject.add(playerAvatar);

        // Spawn kid chaser
        spawnKidChaser();

        // Entities
        spawnCollectibles(COLLECTIBLES_COUNT);
        spawnHazards(HAZARD_COUNT);
        spawnEnemies(enemyCount);
      }

      function createPlayerAvatar() {
        const group = new THREE.Group();
        // Body
        const body = (() => { const mat = new THREE.MeshStandardMaterial({ color: 0x89d9ff, metalness: 0.1, roughness: 0.6 }); const g = new THREE.Group(); const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 0.9, 12), mat); const top = new THREE.Mesh(new THREE.SphereGeometry(0.28, 12, 12), mat); top.position.y = 0.45; const bot = new THREE.Mesh(new THREE.SphereGeometry(0.28, 12, 12), mat); bot.position.y = -0.45; g.add(cyl, top, bot); return g; })();
        body.position.y = 0.9;
        group.add(body);
        // Head with visor
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.24, 16, 12), new THREE.MeshStandardMaterial({ color: 0xeaf7ff, metalness: 0.2, roughness: 0.3 }));
        head.position.y = 1.5; group.add(head);
        const visor = new THREE.Mesh(new THREE.SphereGeometry(0.245, 16, 12, Math.PI * 0.15, Math.PI * 0.7, 0, Math.PI * 0.55), new THREE.MeshStandardMaterial({ color: 0x00364a, emissive: 0x00caff, emissiveIntensity: 0.25, transparent: true, opacity: 0.8 }));
        visor.position.copy(head.position); group.add(visor);
        // Simple run cycle params
        group.userData.animT = 0;
        return group;
      }

      function spawnKidChaser() {
        if (kidChaser && kidChaser.group) { scene.remove(kidChaser.group); }
        const g = new THREE.Group();
        // Torso
        const torso = (() => { const mat = new THREE.MeshStandardMaterial({ color: 0xffe6a8, roughness: 0.7 }); const grp = new THREE.Group(); const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.6, 10), mat); const top = new THREE.Mesh(new THREE.SphereGeometry(0.22, 10, 10), mat); top.position.y = 0.3; const bot = new THREE.Mesh(new THREE.SphereGeometry(0.22, 10, 10), mat); bot.position.y = -0.3; grp.add(cyl, top, bot); return grp; })();
        torso.position.y = 0.7; g.add(torso);
        // Diaper (white band)
        const diaper = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.12, 10, 24), new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.05, roughness: 0.9 }));
        diaper.rotation.x = Math.PI / 2; diaper.position.y = 0.4; g.add(diaper);
        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 12), new THREE.MeshStandardMaterial({ color: 0xffd4a8 }));
        head.position.y = 1.2; g.add(head);
        // Stick (wooden)
        const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.2, 10), new THREE.MeshStandardMaterial({ color: 0x7b4a2f, roughness: 0.8 }));
        stick.position.set(0.35, 0.9, 0); stick.rotation.z = Math.PI / 5; g.add(stick);
        // Eyes
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x000000 });
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 10, 8), eyeMat);
        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.04, 10, 8), eyeMat);
        eyeL.position.set(-0.07, 1.22, 0.18); eyeR.position.set(0.07, 1.22, 0.18); g.add(eyeL, eyeR);
        // Position behind player
        const start = yawObject.position.clone().add(new THREE.Vector3(-1.2, 0, -1.2));
        g.position.copy(start);
        scene.add(g);
        kidChaser = { group: g, speed: 2.5, swing: 0, attackCooldown: 0 };
      }

      // --------------------------
      // Visual extras: Dust, Sweep, Portal glow
      // --------------------------
      function makeCapsule(radius, length, mat) {
        const grp = new THREE.Group();
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 12), mat);
        const top = new THREE.Mesh(new THREE.SphereGeometry(radius, 12, 12), mat); top.position.y = length / 2;
        const bot = new THREE.Mesh(new THREE.SphereGeometry(radius, 12, 12), mat); bot.position.y = -length / 2;
        grp.add(cyl, top, bot);
        return grp;
      }
      function makeCircleSprite(size = 64) {
        const c = document.createElement('canvas'); c.width = size; c.height = size;
        const g = c.getContext('2d');
        const gr = g.createRadialGradient(size / 2, size / 2, 1, size / 2, size / 2, size / 2);
        gr.addColorStop(0, 'rgba(255,255,255,0.9)');
        gr.addColorStop(0.35, 'rgba(255,255,255,0.25)');
        gr.addColorStop(1, 'rgba(255,255,255,0)');
        g.fillStyle = gr; g.fillRect(0, 0, size, size);
        const tex = new THREE.CanvasTexture(c); tex.needsUpdate = true; tex.anisotropy = 4; return tex;
      }

      function setupDustMotes(cols, rows) {
        // remove previous
        if (dustPoints) { scene.remove(dustPoints); dustPoints.geometry.dispose?.(); dustPoints.material.dispose?.(); dustPoints = null; }
        dustData = [];
        const count = Math.min(400, cols * rows * 3);
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const sizes = new Float32Array(count);
        for (let i = 0; i < count; i++) {
          positions[i * 3 + 0] = (Math.random() * cols) * CELL_SIZE;
          positions[i * 3 + 1] = Math.random() * (WALL_HEIGHT * 0.95) + 0.1;
          positions[i * 3 + 2] = (Math.random() * rows) * CELL_SIZE;
          sizes[i] = 0.08 + Math.random() * 0.18;
          dustData.push({ vx: (Math.random() - 0.5) * 0.12, vy: (Math.random() - 0.5) * 0.06 });
        }
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({
          size: 0.6,
          map: makeCircleSprite(64),
          transparent: true,
          depthWrite: false,
          opacity: 0.18,
          sizeAttenuation: true,
          color: new THREE.Color(0xcfffe9)
        });
        dustPoints = new THREE.Points(geo, mat);
        dustPoints.position.set(CELL_SIZE / 2, 0, CELL_SIZE / 2);
        mazeGroup.add(dustPoints);
      }

      function updateDust(dt) {
        if (!dustPoints) return;
        const pos = dustPoints.geometry.getAttribute('position');
        const count = pos.count;
        for (let i = 0; i < count; i++) {
          let x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
          const d = dustData[i];
          x += d.vx + Math.sin(clock.elapsedTime * 0.5 + i) * 0.005;
          y += d.vy + Math.sin(clock.elapsedTime * 0.8 + i * 0.5) * 0.004;
          z += Math.sin(clock.elapsedTime * 0.4 + i * 0.7) * 0.006;
          // bounds
          const maxX = (mazeSize - 1) * CELL_SIZE, maxZ = (mazeSize - 1) * CELL_SIZE;
          if (x < 0) x = maxX; if (x > maxX) x = 0;
          if (z < 0) z = maxZ; if (z > maxZ) z = 0;
          if (y < 0.05) y = WALL_HEIGHT * 0.95; if (y > WALL_HEIGHT * 0.95) y = 0.1;
          pos.setXYZ(i, x, y, z);
        }
        pos.needsUpdate = true;
      }

      function setupLightSweep(cols, rows) {
        if (sweepMesh) { mazeGroup.remove(sweepMesh); sweepMesh.geometry.dispose?.(); sweepMesh.material.dispose?.(); sweepMesh = null; }
        // vertical band that moves across X
        const bandW = CELL_SIZE * 2.5;
        const geo = new THREE.PlaneGeometry(bandW, WALL_HEIGHT * 1.6);
        const c = document.createElement('canvas'); c.width = 64; c.height = 256; const g = c.getContext('2d');
        const grad = g.createLinearGradient(0, 0, 64, 0);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(0.5, 'rgba(180,255,230,0.55)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        g.fillStyle = grad; g.fillRect(0, 0, 64, 256);
        const tex = new THREE.CanvasTexture(c); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.ClampToEdgeWrapping; tex.needsUpdate = true;
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending, depthWrite: false, color: 0xd6ffee });
        sweepMesh = new THREE.Mesh(geo, mat);
        sweepMesh.rotation.y = Math.PI / 2; // vertical plane facing X
        sweepMesh.position.set((cols * CELL_SIZE) / 2, WALL_HEIGHT * 0.9, (rows * CELL_SIZE) / 2);
        mazeGroup.add(sweepMesh);
      }

      function updateLightSweep(dt) {
        if (!sweepMesh) return;
        // oscillate across the maze
        const totalW = (mazeSize) * CELL_SIZE;
        const t = clock.elapsedTime * 0.15;
        sweepMesh.position.x = (totalW / 2) + Math.sin(t) * (totalW * 0.45);
        // pulse walls slightly with the sweep
        const pulse = 0.5 + 0.5 * Math.sin(clock.elapsedTime * 2.0);
        if (wallIMesh?.material) wallIMesh.material.emissiveIntensity = 0.35 + pulse * 0.25;
        if (gridHelper?.material) gridHelper.material.opacity = 0.18 + pulse * 0.1;
      }

      function enhancePortal() {
        if (!exitPortal) return;
        // central halo sprite
        const haloTex = makeCircleSprite(128);
        for (let i = 0; i < 3; i++) {
          const sprMat = new THREE.SpriteMaterial({ map: haloTex, color: new THREE.Color(0xff4d8a), blending: THREE.AdditiveBlending, transparent: true, depthWrite: false, opacity: 0.45 });
          const spr = new THREE.Sprite(sprMat);
          spr.scale.set(2.4 + i * 0.6, 2.4 + i * 0.6, 1);
          spr.position.copy(exitPortal.position).add(new THREE.Vector3(0, 0.4 + i * 0.2, 0));
          portalSprites.push(spr);
          mazeGroup.add(spr);
        }
      }

      // --------------------------
      // Entities
      // --------------------------
      function spawnCollectibles(count) {
        clearArrayMeshes(collectibles);
        const geom = new THREE.SphereGeometry(0.25, 16, 12);
        const mat = new THREE.MeshStandardMaterial({ color: 0x00f0ff, emissive: 0x00e4ff, emissiveIntensity: 0.9, transparent: true, opacity: 0.95 });
        const used = new Set();
        for (let i = 0; i < count; i++) {
          const pos = randomOpenCellExcept([startCell, exitCell], used);
          const mesh = new THREE.Mesh(geom, mat.clone());
          const wpos = cellCenterWorld(pos.x, pos.y);
          mesh.position.set(wpos.x, 0.25, wpos.z);
          mesh.userData.type = 'collectible';
          scene.add(mesh);
          collectibles.push(mesh);
        }
      }

      function spawnHazards(count) {
        clearArrayMeshes(hazards);
        const geom = new THREE.ConeGeometry(0.35, 0.8, 10);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff3366, emissive: 0xff0044, emissiveIntensity: 0.6 });
        const used = new Set();
        for (let i = 0; i < count; i++) {
          const pos = randomOpenCellExcept([startCell, exitCell], used);
          const mesh = new THREE.Mesh(geom, mat.clone());
          mesh.position.copy(cellCenterWorld(pos.x, pos.y));
          mesh.position.y = 0.4;
          mesh.rotation.x = Math.PI;
          mesh.userData.type = 'hazard';
          scene.add(mesh);
          hazards.push(mesh);
        }
      }

      function spawnEnemies(count) {
        // Clear previous YUKA entities
        enemies.forEach(e => { if (entityManager) entityManager.remove(e.vehicle); scene.remove(e.mesh); });
        enemies.length = 0;

        if (!window.YUKA || !entityManager) {
          return; // YUKA unavailable; skip enemies
        }

        for (let i = 0; i < count; i++) {
          const mesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.45, 20, 16),
            new THREE.MeshStandardMaterial({ color: 0xfff000, emissive: 0xffae00, emissiveIntensity: 0.8 })
          );
          scene.add(mesh);

          const vehicle = new YUKA.Vehicle();
          vehicle.maxSpeed = 2.2 + Math.random() * 0.8;

          // Path of random waypoints in open cells
          const path = new YUKA.Path();
          const waypoints = randomWaypoints(mazeSize, 5 + (Math.random() * 4 | 0));
          waypoints.forEach(wp => path.add(new YUKA.Vector3(wp.x, 0, wp.z)));
          path.loop = true;

          const follow = new YUKA.FollowPathBehavior(path, 0.5);
          const onPath = new YUKA.OnPathBehavior(path);
          vehicle.steering.add(follow);
          vehicle.steering.add(onPath);

          // Initial position
          const startWP = path.current();
          vehicle.position.copy(startWP);

          vehicle.setRenderComponent(mesh, (entity, renderComponent) => {
            renderComponent.position.set(entity.position.x, 0.45, entity.position.z);
          });

          entityManager.add(vehicle);
          enemies.push({ vehicle, mesh, path });
        }
      }

      function randomWaypoints(size, n) {
        const pts = [];
        const used = new Set();
        for (let i = 0; i < n; i++) {
          const c = randomOpenCellExcept([startCell, exitCell], used);
          const pos = cellCenterWorld(c.x, c.y);
          pts.push({ x: pos.x, z: pos.z });
        }
        return pts;
      }

      function randomOpenCellExcept(exceptCells, usedSet) {
        // usedSet string keys "x,y"
        for (let attempt = 0; attempt < 1000; attempt++) {
          const idx = (Math.random() * openCells.length) | 0;
          const c = openCells[idx];
          let forbidden = false;
          for (const ex of exceptCells) if (ex.x === c.x && ex.y === c.y) { forbidden = true; break; }
          if (forbidden) continue;
          const k = `${c.x},${c.y}`;
          if (usedSet && usedSet.has(k)) continue;
          usedSet?.add(k);
          return c;
        }
        return { x: 1, y: 1 };
      }

      function clearArrayMeshes(arr) {
        arr.forEach(m => { scene.remove(m); m.geometry?.dispose?.(); if (m.material?.dispose) m.material.dispose(); });
        arr.length = 0;
      }

      // --------------------------
      // Game loop
      // --------------------------
      function beginGame() {
        if (isRunning) return;
        isRunning = true;
        timeRemaining = TIME_LIMIT;
        score = 0;
        health = 100;
        updateHUD();

        startOverlay.style.display = 'none';
        if (!isMobile) requestPointerLock();

        // Enable audio
        try {
          listener.context.resume().then(() => { audioEnabled = true; }).catch(() => { });
        } catch (e) { }

        lastFrameTime = performance.now();
        animate();
      }

      function animate(now) {
        if (!isRunning) return;

        requestAnimationFrame(animate);

        const dt = clock.getDelta();
        const elapsedMs = now - lastFrameTime;
        lastFrameTime = now;

        // Performance monitoring and adaptive scaling
        perf.frames++;
        perf.acc += elapsedMs;
        if (perf.acc > 1000) { // Every second
          perf.fps = Math.round(1000 / (perf.acc / perf.frames));
          perf.acc = 0;
          perf.frames = 0;

          // Adaptive quality scaling
          if (perf.fps < 50) {
            if (perf.level < 2) applyPerfLevel(perf.level + 1);
          } else if (perf.fps > 58 && perf.level > 0) {
            applyPerfLevel(perf.level - 1);
          }
        }

        // Player input -> movement
        updateMovement(dt);
        updateThirdPersonCamera(dt);
        updateKidChaser(dt);

        // Enemies (YUKA) - Staggered updates for performance
        if (entityManager && perf.frames % 3 === 0) {
          entityManager.update(dt);
        }

        // Collisions with enemies/hazards/collectibles
        updateInteractions(dt);

        // Timer
        timeRemaining -= dt;
        if (timeRemaining <= 0) {
          timeRemaining = 0;
          endGame(false);
        }

        // Exit portal rotation
        if (exitPortal) exitPortal.rotation.y += dt * 1.5;

        // Simple float for collectibles + emissive pulse - Staggered for performance
        if (perf.frames % 3 === 0) {
          const pulse = 0.6 + 0.4 * Math.sin(clock.elapsedTime * 2.4);
          for (const c of collectibles) {
            c.position.y = 0.25 + Math.sin(now * 0.002 + c.id) * 0.07;
            if (c.material) c.material.emissiveIntensity = 0.6 + 0.4 * pulse;
          }
        }

        // Lights follow player softly and flicker slightly (scale with perf level)
        pointLight.position.lerp(new THREE.Vector3(yawObject.position.x, 6, yawObject.position.z), 0.08);
        if (perf.frames % 2 === 0) {
          const flickerScale = perf.level === 2 ? 0.0 : (perf.level === 1 ? 0.5 : 1.0);
          pointLight.intensity = 0.95 + Math.sin(clock.elapsedTime * 6.5) * 0.05 * flickerScale;
          ambientLight.intensity = 0.32 + Math.sin(clock.elapsedTime * 0.8) * 0.03 * flickerScale;
        }

        // Update dust and sweep - Staggered for performance
        if (perf.frames % 2 === 0) updateDust(dt);
        if (perf.frames % 4 === 0) updateLightSweep(dt);

        // Proximity painting upscaling disabled for performance

        // Portal halo slow rotation - Staggered for performance
        if (perf.frames % 2 === 0) {
          for (let i = 0; i < portalSprites.length; i++) {
            const s = portalSprites[i];
            if (!s || !s.material) continue;
            s.material.opacity = 0.35 + 0.15 * Math.sin(clock.elapsedTime * (1.2 + i * 0.2));
            // Sprites rotate via material.rotation (in radians)
            if (typeof s.material.rotation === 'number') {
              s.material.rotation += 0.002 * (i % 2 === 0 ? 1 : -1);
            }
          }
        }

        // TF.js sampling
        samplePlayerForAI(dt);

        renderer.render(scene, camera);
        updateHUD();
      }

      function updateMovement(dt) {
        // Input vector: forward/back, left/right
        let inputForward = 0, inputRight = 0;
        if (isMobile) {
          inputForward = -mobileMoveInput.y;
          inputRight = mobileMoveInput.x;
        } else {
          inputForward = (keyState.w ? 1 : 0) + (keyState.s ? -1 : 0);
          inputRight = (keyState.d ? 1 : 0) + (keyState.a ? -1 : 0);
        }

        const speed = (keyState.shift ? PLAYER_SPRINT_SPEED : PLAYER_BASE_SPEED);
        const moveSpeed = speed * dt;

        // Compute world-space movement from yaw
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
        forward.y = 0; forward.normalize();
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

        const moveVec = new THREE.Vector3();
        moveVec.addScaledVector(forward, inputForward);
        moveVec.addScaledVector(right, inputRight);
        if (moveVec.lengthSq() > 1e-5) moveVec.normalize();

        // Jumping and gravity
        if (keyState.space && isOnGround) {
          velocityY = JUMP_VELOCITY;
          isOnGround = false;
          playBeep(660, 0.04, 0.1);
        }
        velocityY -= GRAVITY * dt;
        const nextPos = yawObject.position.clone();

        // Horizontal movement with collision (axis slide + substeps)
        const desired = moveVec.clone().multiplyScalar(moveSpeed);
        const steps = Math.max(1, Math.ceil(desired.length() / 0.3));
        const step = desired.clone().multiplyScalar(1 / steps);
        for (let i = 0; i < steps; i++) {
          const dx = new THREE.Vector3(step.x, 0, 0);
          if (!willCollide(nextPos, dx)) nextPos.add(dx);
          const dz = new THREE.Vector3(0, 0, step.z);
          if (!willCollide(nextPos, dz)) nextPos.add(dz);
        }

        // Vertical (simple ground at y=0)
        nextPos.y += velocityY * dt;
        if (nextPos.y <= 0) {
          nextPos.y = 0;
          velocityY = 0;
          isOnGround = true;
        }

        // Trigger footstep when contacting ground after moving
        const prevY = yawObject.position.y;
        yawObject.position.copy(nextPos);
        pitchObject.position.y = PLAYER_EYE_HEIGHT;
        // Footstep cadence based on horizontal speed
        const horizSpeed = desired.length() / dt;
        if (isOnGround && horizSpeed > 1.0) {
          if (!updateMovement._stepTimer) updateMovement._stepTimer = 0;
          updateMovement._stepTimer -= dt;
          if (updateMovement._stepTimer <= 0) {
            playFootstep(Math.min(1.5, 0.5 + horizSpeed * 0.06));
            updateMovement._stepTimer = 0.34 / Math.min(2.2, (1.0 + horizSpeed * 0.12));
          }
        }
        // Animate player avatar simple bob
        if (playerAvatar) {
          playerAvatar.userData.animT += dt * (isOnGround ? (2.5 + (keyState.shift ? 1.2 : 0)) : 1.0);
          const t = playerAvatar.userData.animT;
          playerAvatar.position.y = Math.sin(t * 6) * 0.05;
          playerAvatar.rotation.y = Math.atan2(moveVec.x, moveVec.z);
        }
      }

      function updateThirdPersonCamera(dt) {
        // Tighter follow: nearer camera with simple wall avoidance to prevent occlusion
        const eye = yawObject.position.clone();
        eye.y += 1.2;
        const camOffsetLocal = new THREE.Vector3(0, 0.9, 2.2);
        const rot = new THREE.Euler(0, yawObject.rotation.y, 0, 'YXZ');
        const desiredOffset = camOffsetLocal.clone().applyEuler(rot);
        let targetPos = eye.clone().add(desiredOffset);

        // Raycast from eye to desired camera position to avoid walls between
        const toCam = targetPos.clone().sub(eye);
        const dist = toCam.length();
        if (dist > 1e-4) {
          toCam.normalize();
          raycaster.set(eye.clone(), toCam);
          const hit = wallIMesh ? raycaster.intersectObject(wallIMesh, false) : [];
          if (hit.length && hit[0].distance < dist) {
            const margin = 0.35;
            const d = Math.max(0.8, hit[0].distance - margin);
            targetPos = eye.clone().add(toCam.multiplyScalar(d));
          }
        }

        camera.position.lerp(targetPos, 0.2);
        camera.lookAt(eye.x, eye.y, eye.z);
      }

      function updateKidChaser(dt) {
        if (!kidChaser || !kidChaser.group) return;
        const g = kidChaser.group;
        // Move towards player position with simple steering
        const toPlayer = yawObject.position.clone().sub(g.position);
        toPlayer.y = 0;
        const dist = toPlayer.length();
        if (dist > 0.001) toPlayer.normalize();
        const speed = kidChaser.speed * (1.0 + Math.min(1.5, Math.max(0, (score / 4000))));
        // Collision-aware movement in substeps
        const desired = toPlayer.clone().multiplyScalar(speed * dt);
        const steps = Math.max(1, Math.ceil(desired.length() / 0.25));
        const step = desired.clone().multiplyScalar(1 / steps);
        for (let i = 0; i < steps; i++) {
          const dx = new THREE.Vector3(step.x, 0, 0);
          if (!willCollideAt(g.position, dx, 0.9, 0.32)) g.position.add(dx);
          const dz = new THREE.Vector3(0, 0, step.z);
          if (!willCollideAt(g.position, dz, 0.9, 0.32)) g.position.add(dz);
        }
        // Face player
        g.lookAt(yawObject.position.x, g.position.y, yawObject.position.z);
        // Stick swing animation + occasional distant laugh
        kidChaser.swing += dt * 6;
        const swingAngle = Math.sin(kidChaser.swing) * 0.4;
        g.children.forEach(ch => { if (ch.geometry && ch.geometry.type === 'CylinderGeometry') ch.rotation.z = swingAngle; });
        if (Math.random() < 0.003) playLaugh(false);
        // Attack hit when close
        kidChaser.attackCooldown -= dt; if (kidChaser.attackCooldown < 0) kidChaser.attackCooldown = 0;
        if (dist < 0.9 && kidChaser.attackCooldown === 0) {
          health = Math.max(0, health - 14);
          pushDamageFlash();
          playHitThwack();
          if (Math.random() < 0.6) setTimeout(() => playLaugh(true), 120);
          kidChaser.attackCooldown = 0.9;
          if (health <= 0) endGame(false);
        }
      }

      function pushDamageFlash() {
        // Briefly boost ambient color
        if (ambientLight) ambientLight.color.setHex(0xff6666);
        setTimeout(() => { if (ambientLight) ambientLight.color.setHex(0x88ffc8); }, 60);
      }

      function willCollide(origin, delta) {
        if (!wallIMesh) return false;
        const dir = delta.clone();
        const dist = dir.length();
        if (dist < 1e-4) return false;
        dir.normalize();

        const rayOrigin = new THREE.Vector3(origin.x, PLAYER_EYE_HEIGHT * 0.5, origin.z);
        raycaster.set(rayOrigin, dir);
        const intersects = raycaster.intersectObject(wallIMesh, false);
        if (intersects.length > 0) {
          const d = intersects[0].distance;
          if (d < PLAYER_RADIUS + dist + WALL_THICKNESS * 0.5) {
            return true;
          }
        }
        return false;
      }

      // Generic collision test for other entities
      function willCollideAt(origin, delta, eyeHeight = 0.9, radius = 0.35) {
        if (!wallIMesh) return false;
        const dir = delta.clone();
        const dist = dir.length();
        if (dist < 1e-4) return false;
        dir.normalize();
        const rayOrigin = new THREE.Vector3(origin.x, eyeHeight, origin.z);
        raycaster.set(rayOrigin, dir);
        const intersects = raycaster.intersectObject(wallIMesh, false);
        if (intersects.length > 0) {
          const d = intersects[0].distance;
          if (d < radius + dist + WALL_THICKNESS * 0.5) return true;
        }
        return false;
      }

      // --------------------------
      // Interactions
      // --------------------------
      let hurtCooldown = 0;
      function updateInteractions(dt) {
        const playerPos = yawObject.position;

        // Win condition
        if (playerPos.distanceTo(exitPosition) < 1.2 && health > 0) {
          score += Math.floor(timeRemaining * 10);
          endGame(true);
          return;
        }

        // Collectibles
        for (let i = collectibles.length - 1; i >= 0; i--) {
          const c = collectibles[i];
          if (c.position.distanceTo(playerPos) < 0.9) {
            score += 50;
            scene.remove(c);
            c.geometry.dispose?.(); c.material.dispose?.();
            collectibles.splice(i, 1);
            playBeep(880, 0.06, 0.12);
          }
        }

        // Hazards and enemies
        hurtCooldown -= dt;
        if (hurtCooldown < 0) hurtCooldown = 0;

        let damaged = false;
        for (const h of hazards) {
          if (h.position.distanceTo(playerPos) < 0.9) { damaged = true; break; }
        }
        if (!damaged) {
          for (const e of enemies) {
            const pos = e.mesh.position;
            if (pos.distanceTo(playerPos) < 0.85) { damaged = true; break; }
          }
        }
        if (damaged && hurtCooldown <= 0) {
          health = Math.max(0, health - 12);
          hurtCooldown = 0.6;
          playBeep(220, 0.06, 0.15);
          if (health <= 0) endGame(false);
        }
      }

      // --------------------------
      // HUD and endgame
      // --------------------------
      function updateHUD() {
        hudTime.textContent = Math.ceil(timeRemaining).toString();
        hudScore.textContent = score.toString();
        hudHealth.textContent = health.toString();
        healthBar.style.width = `${health}%`;

        // Update FPS display
        const fpsElement = document.getElementById('fps');
        if (fpsElement) {
          fpsElement.textContent = perf.fps || 60;
        }
      }

      function endGame(win) {
        if (!isRunning) return;
        isRunning = false;

        endOverlay.style.display = 'flex';
        endTitle.textContent = win ? 'You Escaped!' : 'Run Failed';
        const finalScore = score;
        let detail = `Score: ${finalScore}`;
        if (win) detail += `  Time left: ${Math.ceil(timeRemaining)}s`;
        if (collectibles.length < COLLECTIBLES_COUNT) {
          const collected = COLLECTIBLES_COUNT - collectibles.length;
          detail += `  Orbs: ${collected}/${COLLECTIBLES_COUNT}`;
        }
        endDetails.textContent = detail;

        // Save best + scale difficulty
        if (finalScore > bestScore) {
          bestScore = finalScore;
          localStorage.setItem(STORAGE_KEYS.best, String(bestScore));
          hudBest.textContent = bestScore;
          difficultyLevel = Math.min(difficultyLevel + 1, 20);
          localStorage.setItem(STORAGE_KEYS.difficulty, String(difficultyLevel));
        } else {
          // Mild decay if many losses
          if (!win && difficultyLevel > 0) {
            difficultyLevel = Math.max(0, difficultyLevel - 1);
            localStorage.setItem(STORAGE_KEYS.difficulty, String(difficultyLevel));
          }
        }

        // celebratory tone
        if (win) {
          playBeep(1046, 0.08, 0.18);
          setTimeout(() => playBeep(1318, 0.08, 0.18), 120);
        }
        document.exitPointerLock?.();
      }

      // --------------------------
      // Audio (procedural bleeps)
      // --------------------------
      function playBeep(freq = 440, len = 0.05, gain = 0.08) {
        if (!audioEnabled || !listener?.context) return;
        try {
          const ctx = listener.context;
          const osc = ctx.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = freq;

          const g = ctx.createGain();
          g.gain.value = 0;
          g.connect(sfxGain || masterGain);

          const now = ctx.currentTime;
          const attack = 0.005;
          const decay = len;

          g.gain.setValueAtTime(0, now);
          g.gain.linearRampToValueAtTime(gain, now + attack);
          g.gain.exponentialRampToValueAtTime(0.0001, now + attack + decay);

          osc.connect(g);
          osc.start(now);
          osc.stop(now + attack + decay + 0.02);
        } catch (e) { }
      }

      // ---------------------------------
      // Creative SFX: footsteps, laugh, hit
      // ---------------------------------
      function playFootstep(intensity = 1) {
        if (!audioEnabled || !listener?.context) return;
        const ctx = listener.context;
        const o1 = ctx.createOscillator();
        const o2 = ctx.createOscillator();
        const g = ctx.createGain(); g.connect(sfxGain || masterGain);
        const t = ctx.currentTime;
        o1.type = 'square'; o2.type = 'triangle';
        const base = 120 + Math.random() * 30;
        o1.frequency.setValueAtTime(base, t);
        o2.frequency.setValueAtTime(base * 2, t);
        const vol = 0.02 * intensity;
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(vol, t + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
        o1.connect(g); o2.connect(g);
        o1.start(t); o2.start(t);
        o1.stop(t + 0.14); o2.stop(t + 0.14);
      }

      function playLaugh(chuckle = false) {
        if (!audioEnabled || !listener?.context) return;
        const ctx = listener.context; const t = ctx.currentTime;
        const g = ctx.createGain(); g.connect(sfxGain || masterGain);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.12, t + 0.05);
        g.gain.exponentialRampToValueAtTime(0.0001, t + (chuckle ? 0.35 : 0.75));
        const osc = ctx.createOscillator(); osc.type = 'sawtooth';
        const base = chuckle ? 220 : 180;
        osc.frequency.setValueAtTime(base, t);
        osc.frequency.exponentialRampToValueAtTime(base * 0.6, t + (chuckle ? 0.35 : 0.75));
        const filt = ctx.createBiquadFilter(); filt.type = 'bandpass'; filt.Q.value = 8; filt.frequency.value = 600;
        osc.connect(filt); filt.connect(g);
        osc.start(t); osc.stop(t + (chuckle ? 0.37 : 0.77));
      }

      function playHitThwack() {
        if (!audioEnabled || !listener?.context) return;
        const ctx = listener.context; const t = ctx.currentTime;
        const noise = ctx.createBufferSource();
        const buffer = ctx.createBuffer(1, 4410, 44100);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) { data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2); }
        noise.buffer = buffer;
        const filt = ctx.createBiquadFilter(); filt.type = 'lowpass'; filt.frequency.setValueAtTime(900, t);
        const g = ctx.createGain(); g.connect(sfxGain || masterGain);
        g.gain.setValueAtTime(0.001, t);
        g.gain.linearRampToValueAtTime(0.25, t + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);
        noise.connect(filt); filt.connect(g);
        noise.start(t); noise.stop(t + 0.26);
      }

      // --------------------------
      // TF.js (AI hooks)
      // --------------------------
      function samplePlayerForAI(dt) {
        // sample at ~10Hz
        if (positionSamples.length === 0 || Math.random() < 0.1) {
          positionSamples.push({
            t: performance.now() * 0.001,
            x: yawObject.position.x,
            z: yawObject.position.z
          });
          if (positionSamples.length > 400) positionSamples.shift();
        }

        aiAdaptCooldown -= dt;
        if (aiAdaptCooldown <= 0) {
          aiAdaptCooldown = 10; // evaluate every 10s
          try {
            predictPlayerSkill().then(skill => {
              // Simple adaptation: if predicted skill high, increase challenge mid-run
              if (skill > 0.7 && enemies.length < 7) {
                spawnEnemies(enemies.length + 1);
                playBeep(900, 0.05, 0.12);
              }
            }).catch(() => { });
          } catch (e) { }
        }
      }

      async function predictPlayerSkill() {
        if (typeof tf === 'undefined') return 0.5;
        // Feature: average horizontal speed over last N samples
        if (positionSamples.length < 5) return 0.5;

        let vSum = 0, n = 0;
        for (let i = 1; i < positionSamples.length; i++) {
          const a = positionSamples[i - 1];
          const b = positionSamples[i];
          const dt = b.t - a.t;
          if (dt <= 0) continue;
          const dx = b.x - a.x;
          const dz = b.z - a.z;
          const v = Math.hypot(dx, dz) / dt;
          vSum += v; n++;
        }
        const avgSpeed = n > 0 ? vSum / n : 0;

        // Lazy one-layer model (placeholder). Maps speed to 0..1 likelihood of "high skill".
        if (!tfModel) {
          tfModel = tf.sequential();
          tfModel.add(tf.layers.dense({ units: 4, inputShape: [1], activation: 'relu', kernelInitializer: 'heNormal' }));
          tfModel.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
          tfModel.compile({ optimizer: 'adam', loss: 'binaryCrossentropy' });

          // Quick pseudo-training on synthetic data
          const xs = tf.tensor2d([0.3, 0.8, 1.2, 1.6, 2.2, 2.8, 3.4], [7, 1]);
          const ys = tf.tensor2d([0.1, 0.2, 0.35, 0.6, 0.8, 0.9, 0.95], [7, 1]);
          await tfModel.fit(xs, ys, { epochs: 10, verbose: 0 }).catch(() => { });
        }

        const pred = tf.tidy(() => tfModel.predict(tf.tensor2d([avgSpeed], [1, 1])));
        const val = (await pred.data())[0];
        pred.dispose();
        return isNaN(val) ? 0.5 : clamp(val, 0, 1);
      }

      // --------------------------
      // Start
      // --------------------------
      init();

      // Clicking anywhere on overlay starts + pointer lock
      renderer.domElement.addEventListener('click', () => {
        if (!isRunning && startOverlay.style.display !== 'none') beginGame();
        else requestPointerLock();
      });

      // -------------
      // Helper: Debug
      // -------------
      console.log('Maze size:', mazeSize, 'Enemies:', enemyCount, 'Difficulty:', difficultyLevel);

    });
  </script>
</body>

</html>